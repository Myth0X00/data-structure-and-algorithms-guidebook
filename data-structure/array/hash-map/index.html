<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <link
      rel="stylesheet"
      href="/data-structure-and-algorithms-guidebook/umi.css"
    />
    <script>
      window.routerBase = "/data-structure-and-algorithms-guidebook/";
    </script>
    <script>
      //! umi version: 3.2.20
    </script>
    <title>哈希表</title>
  
</head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//">Data Structure and Algorithms Guidebook</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a><a href="/data-structure-and-algorithms-guidebook//algorithms">算法</a><a href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//"></a><h1>Data Structure and Algorithms Guidebook</h1><p>数据结构与算法完全知识体系</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms">算法</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a></li><li><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a></li><li><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure/array">数组</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/array"><span>数组</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/string"><span>字符串</span></a></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map"><span>哈希表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/pattern-match"><span>模式匹配</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/multiple-patterns-match"><span>多模式匹配</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/regex"><span>正则表达式</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list">线性表</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/linear-list"><span>线性表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/singly-linked-list"><span>单链表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/double-linked-list"><span>双链表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/circular-linked-list"><span>循环链表</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack">栈与队列</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/stack"><span>栈</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/queue"><span>队列</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/circular-queue"><span>循环队列</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/multiple-level-feedback-queue"><span>多级反馈队列</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/priority-queue"><span>优先队列</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree">树</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/tree"><span>树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-tree"><span>二叉树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree"><span>二叉查找树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/avl-tree"><span>AVL 树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/red-black-tree"><span>红黑树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/b-tree"><span>B 树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/b-plus-tree"><span>B+ 树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/fenwick-tree"><span>索引二叉树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/heap"><span>堆</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/index-heap"><span>索引堆</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/treap"><span>树堆</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/disjoint-set"><span>并查集</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/segment-tree"><span>线段树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/splay-tree"><span>伸展树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/trie-tree"><span>前缀树</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/graph">图形</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/graph/graph"><span>图</span></a></li></ul></li></ul></div></div><ul class="__dumi-default-layout-toc" role="slug-list"><li title="原理" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map#原理"><span>原理</span></a></li><li title="设计关键" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map#设计关键"><span>设计关键</span></a></li><li title="哈希函数" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map#哈希函数"><span>哈希函数</span></a></li><li title="冲突解决" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map#冲突解决"><span>冲突解决</span></a></li><li title="实际应用" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map#实际应用"><span>实际应用</span></a></li><li title="哈希集合" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map#哈希集合"><span>哈希集合</span></a></li><li title="哈希映射" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map#哈希映射"><span>哈希映射</span></a></li><li title="设计键" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map#设计键"><span>设计键</span></a></li><li title="小结" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map#小结"><span>小结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="哈希表"><a aria-hidden="true" href="#哈希表"><span class="icon icon-link"></span></a>哈希表</h1><p><code>哈希表</code> 是一种使用 <code>哈希函数</code> 组织数据，以支持快速插入和搜索的数据结构。</p><p>有两种不同类型的哈希表：哈希集合和哈希映射。</p><ul><li><code>哈希集合</code> 是 <code>集合</code> 数据结构的实现之一，用于存储 <code>非重复值</code>。</li><li><code>哈希映射</code> 是 <code>映射</code> 数据结构的实现之一，用于存储 <code>(key, value)</code> 键值对。</li></ul><p>在 <code>标准模板库</code> 的帮助下，哈希表是 <code>易于使用的</code>。大多数常见语言（如 Java，C ++ 和 Python）都支持哈希集合和哈希映射。</p><p>通过选择合适的哈希函数，哈希表可以在插入和搜索方面实现 <code>出色的性能</code>。</p><h2 id="原理"><a aria-hidden="true" href="#原理"><span class="icon icon-link"></span></a>原理</h2><p>正如我们在介绍中提到的，<code>哈希表</code> 是一种数据结构，它使用哈希函数组织数据，以支持 <code>快速插入和搜索</code>。在本文中，我们将简要说明哈希表的原理。</p><p>哈希表的关键思想是使用 <strong>哈希函数</strong> <code>将键映射到存储桶</code>。更确切地说，</p><ol><li>当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；</li><li>当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。</li></ol><p>🌰 <strong>示例：</strong></p></div><img alt="哈希表原理示例" src="/data-structure-and-algorithms-guidebook/static/easy-sample.4a72940b.png" width="360"/><div class="markdown"><p>在示例中，我们使用 <code>y = x ％ 5</code> 作为哈希函数。让我们使用这个例子来完成插入和搜索策略：</p><ol><li>插入：我们通过哈希函数解析键，将它们映射到相应的桶中。<ul><li>例如，1987 分配给桶 2，而 24 分配给桶 4。</li></ul></li><li>搜索：我们通过相同的哈希函数解析键，并仅在特定存储桶中搜索。<ul><li>如果我们搜索 1987，我们将使用相同的哈希函数将 1987 映射到 2。因此我们在桶 2 中搜索，我们在那个桶中成功找到了 1987。</li><li>例如，如果我们搜索 23，将映射 23 到 3，并在桶 3 中搜索。我们发现 23 不在桶 3 中，这意味着 23 不在哈希表中。</li></ul></li></ol><p><code>插入</code> 和 <code>搜索</code> 是哈希表中的两个基本操作。</p><h2 id="设计关键"><a aria-hidden="true" href="#设计关键"><span class="icon icon-link"></span></a>设计关键</h2><p>在设计哈希表时，你应该注意两个基本因素。</p><h3 id="哈希函数"><a aria-hidden="true" href="#哈希函数"><span class="icon icon-link"></span></a>哈希函数</h3><p>哈希函数是哈希表中最重要的组件，该哈希表用于将键映射到特定的桶。在上一篇文章中的示例中，我们使用 <code>y = x % 5</code> 作为散列函数，其中 <code>x</code> 是键值，<code>y</code> 是分配的桶的索引。</p><p>散列函数将取决于 <code>键值的范围</code> 和 <code>桶的数量</code>。</p><p>下面是一些哈希函数的示例：</p></div><img alt="哈希函数" src="/data-structure-and-algorithms-guidebook/static/hash-function.3c25bd8f.png" width="640"/><div class="markdown"><p>哈希函数的设计是一个开放的问题。其思想是尽可能将键分配到桶中，理想情况下，完美的哈希函数将是键和桶之间的一对一映射。然而，在大多数情况下，哈希函数并不完美，它需要在桶的数量和桶的容量之间进行权衡。</p><h3 id="冲突解决"><a aria-hidden="true" href="#冲突解决"><span class="icon icon-link"></span></a>冲突解决</h3><p>理想情况下，如果我们的哈希函数是完美的一对一映射，我们将不需要处理冲突。不幸的是，在大多数情况下，冲突几乎是不可避免的。例如，在我们之前的哈希函数 <code>y = x ％ 5</code> 中，1987 和 2 都分配给了桶 2，这是一个冲突。</p><p>冲突解决算法应该解决以下几个问题：</p><ol><li>如何组织在同一个桶中的值？</li><li>如果为同一个桶分配了太多的值，该怎么办？</li><li>如何在特定的桶中搜索目标值？</li></ol><p>根据我们的哈希函数，这些问题与 <code>桶的容量</code> 和可能映射到 <code>同一个桶</code> 的 <code>键的数目</code> 有关。</p><p>让我们假设存储最大键数的桶有 <code>N</code> 个键。</p><p>通常，如果 <code>N</code> 是常数且很小，我们可以简单地使用一个数组将键存储在同一个桶中。如果 N 是可变的或很大，我们可能需要使用 <code>高度平衡的二叉树</code> 来代替。</p><h2 id="实际应用"><a aria-hidden="true" href="#实际应用"><span class="icon icon-link"></span></a>实际应用</h2><h3 id="哈希集合"><a aria-hidden="true" href="#哈希集合"><span class="icon icon-link"></span></a>哈希集合</h3><p><code>哈希集</code> 是集合的实现之一，它是一种存储 <code>不重复值</code> 的数据结构。</p><h3 id="哈希映射"><a aria-hidden="true" href="#哈希映射"><span class="icon icon-link"></span></a>哈希映射</h3><p><code>哈希映射</code> 是用于存储 <code>(key, value)</code> 键值对的一种实现。</p><h3 id="设计键"><a aria-hidden="true" href="#设计键"><span class="icon icon-link"></span></a>设计键</h3><p>在以前的问题中，键的选择相对简单。不幸的是，有时你必须考虑在使用哈希表时设计合适的键。</p><p>解决方案：</p><p>实际上，<code>设计关键</code> 是在原始信息和哈希映射使用的实际键之间 <code>建立映射关系</code>。设计键时，需要保证：</p><blockquote><ol><li>属于同一组的所有值都将映射到同一组中。</li><li>需要分成不同组的值不会映射到同一组。</li></ol></blockquote><p>此过程类似于设计哈希函数，但这是一个本质区别。哈希函数满足第一个规则但 <code>可能不满足第二个规则</code>。但是你的映射函数应该满足它们。</p><p>在上面的示例中，我们的映射策略可以是：对字符串进行排序并使用排序后的字符串作为键。也就是说，<code>“eat”</code> 和 <code>“ate”</code> 都将映射到 <code>“aet”</code>。</p><p>这里有一些为你准备的关于如何设计键的建议。</p><ol><li>当字符串 / 数组中每个元素的顺序不重要时，可以使用 <code>排序后的字符串 / 数组</code> 作为键。</li></ol></div><img alt="排序后字符串" src="/data-structure-and-algorithms-guidebook/static/summary1.e16c44a8.png" width="360"/><div class="markdown"><ol start="2"><li>如果只关心每个值的偏移量，通常是第一个值的偏移量，则可以使用 <code>偏移量</code> 作为键。</li></ol></div><img alt="偏移量" src="/data-structure-and-algorithms-guidebook/static/summary2.bdb9b3a4.png" width="360"/><div class="markdown"><ol start="3"><li>在树中，你有时可能会希望直接使用 <code>TreeNode</code> 作为键。 但在大多数情况下，采用 <code>子树的序列化表述</code> 可能是一个更好的主意。</li></ol></div><img alt="子树的序列化表述" src="/data-structure-and-algorithms-guidebook/static/summary3.35cb7082.png" width="360"/><div class="markdown"><ol start="4"><li>在矩阵中，你可能希望使用 <code>行索引</code> 或 <code>列索引</code> 作为键。</li></ol><p>5) 在数独中，可以将行索引和列索引组合来标识此元素属于哪个 <code>块</code>。</p></div><img alt="块" src="/data-structure-and-algorithms-guidebook/static/summary4.174d4abd.png" width="360"/><div class="markdown"><ol start="6"><li>有时，在矩阵中，您可能希望将值聚合在 <code>同一对角线</code> 中。</li></ol></div><img alt="同一对角线" src="/data-structure-and-algorithms-guidebook/static/summary5.49191d3c.png" width="360"/><div class="markdown"><h2 id="小结"><a aria-hidden="true" href="#小结"><span class="icon icon-link"></span></a>小结</h2></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/leetcode/edit/master/docs/data-structure/array/hash-map.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last Update: ">9/10/2020, 4:48:41 PM</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/data-structure-and-algorithms-guidebook/umi.js"></script>
    <script src="/data-structure-and-algorithms-guidebook/docs__data-structure__array__hash-map.md.js"></script>
  </body>
</html>
