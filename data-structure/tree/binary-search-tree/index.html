<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <link
      rel="stylesheet"
      href="/data-structure-and-algorithms-guidebook/umi.css"
    />
    <script>
      window.routerBase = "/data-structure-and-algorithms-guidebook/";
    </script>
    <script>
      //! umi version: 3.2.22
    </script>
    <title>二叉查找树</title>
  
</head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//">Data Structure and Algorithms Guidebook</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a><a href="/data-structure-and-algorithms-guidebook//algorithms">算法</a><a href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//"></a><h1>Data Structure and Algorithms Guidebook</h1><p>数据结构与算法完全知识体系</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms">算法</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a></li><li><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a></li><li><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array">数组</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/array"><span>数组</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/string"><span>字符串</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map"><span>哈希表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/pattern-match"><span>模式匹配</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/multiple-patterns-match"><span>多模式匹配</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/regex"><span>正则表达式</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list">线性表</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/linear-list"><span>线性表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/singly-linked-list"><span>单链表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/double-linked-list"><span>双链表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/circular-linked-list"><span>循环链表</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack">栈与队列</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/stack"><span>栈</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/queue"><span>队列</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/circular-queue"><span>循环队列</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/multiple-level-feedback-queue"><span>多级反馈队列</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/priority-queue"><span>优先队列</span></a></li></ul></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure/tree">树</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/tree"><span>树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-tree"><span>二叉树</span></a></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree"><span>二叉查找树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/avl-tree"><span>AVL 树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/red-black-tree"><span>红黑树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/b-tree"><span>B 树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/b-plus-tree"><span>B+ 树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/fenwick-tree"><span>索引二叉树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/heap"><span>堆</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/index-heap"><span>索引堆</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/treap"><span>树堆</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/disjoint-set"><span>并查集</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/segment-tree"><span>线段树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/splay-tree"><span>伸展树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/trie-tree"><span>前缀树</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/graph">图形</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/graph/graph"><span>图</span></a></li></ul></li></ul></div></div><ul class="__dumi-default-layout-toc" role="slug-list"><li title="优势" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#优势"><span>优势</span></a></li><li title="实现" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#实现"><span>实现</span></a></li><li title="插入操作" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#插入操作"><span>插入操作</span></a></li><li title="遍历操作" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#遍历操作"><span>遍历操作</span></a></li><li title="搜索操作" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#搜索操作"><span>搜索操作</span></a></li><li title="删除操作" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#删除操作"><span>删除操作</span></a></li><li title="特性" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#特性"><span>特性</span></a></li><li title="局限性" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#局限性"><span>局限性</span></a></li><li title="高度平衡的二叉查找树" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#高度平衡的二叉查找树"><span>高度平衡的二叉查找树</span></a></li><li title="必要性" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#必要性"><span>必要性</span></a></li><li title="实现方式" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#实现方式"><span>实现方式</span></a></li><li title="实际应用" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree#实际应用"><span>实际应用</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="二叉查找树"><a aria-hidden="true" href="#二叉查找树"><span class="icon icon-link"></span></a>二叉查找树</h1><p><strong>二叉查找树</strong>（Binary Search Tree），也称为<strong>二叉查找树</strong>、<strong>有序二叉树</strong>（Ordered Binary Tree）或<strong>排序二叉树</strong>（Sorted Binary Tree），是指一棵空树或者具有下列性质的二叉树：</p><ul><li>若任意节点的 <strong>左子树</strong> 不为空，则左子树上所有节点的值 <strong style="color:red">均小于</strong> 它的根节点的值</li><li>若任意节点的 <strong>右子树</strong> 不为空，则右子树上所有节点的值 <strong style="color:red">均大于或等于</strong> 它的根节点的值</li><li>任意节点的左、右子树也分别为二叉查找树</li><li>没有键值相等的节点</li></ul></div><img alt="二叉查找树" src="/data-structure-and-algorithms-guidebook/static/binary-search-tree.5d170107.png" width="25%"/><div class="markdown"><blockquote><p>二叉查找树不一定是完全二叉树，所以用数组并不方便，因此通常设立 TreeNode 节点表示 key-value，节点间联系通常使用指针和引用。</p></blockquote><h2 id="优势"><a aria-hidden="true" href="#优势"><span class="icon icon-link"></span></a>优势</h2><p>二叉查找树的优点是，即便在最坏的情况下，也允许你在 <code>O(h)</code> 的时间复杂度内执行所有的搜索、插入、删除操作。</p><p>通常来说，如果你想有序地存储数据或者需要同时执行搜索、插入、删除等多步操作，二叉查找树这个数据结构是一个很好的选择。</p><table><thead><tr><th align="left"></th><th align="left">查找元素</th><th align="left">插入元素</th><th align="left">删除元素</th></tr></thead><tbody><tr><td align="left">普通数组</td><td align="left"><code>O(n)</code></td><td align="left"><code>O(n)</code></td><td align="left"><code>O(n)</code></td></tr><tr><td align="left">顺序数组</td><td align="left"><code>O(log n)</code></td><td align="left"><code>O(n)</code></td><td align="left"><code>O(n)</code></td></tr><tr><td align="left">二分搜索树</td><td align="left"><code>O(log n)</code></td><td align="left"><code>O(log n)</code></td><td align="left"><code>O(log n)</code></td></tr></tbody></table><p>高效：不仅可查找数据；还可以高效地插入、删除数据（动态维护数据）</p><p>可以方便地解决很多数据之间的关系问题：min、max、floor、ceil、rank、select</p><h2 id="实现"><a aria-hidden="true" href="#实现"><span class="icon icon-link"></span></a>实现</h2><p>二叉查找树主要支持三个操作：搜索、插入和删除。</p><p>根据上面的知识，我们了解到二叉树实际上是由多个节点组成，因此我们首先要定义一个 TreeNode 类，用于存放树的节点，其构造与链表类似。</p><p>TreeNode 类的定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="function TreeNode(value, left, right) {
  this.value = value;
  this.left = left;
  this.right = right;
}
" data-status="copy"></button><div class="token-line"><span class="token keyword">function</span><span class="token plain"> </span><span class="token function maybe-class-name">TreeNode</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token parameter punctuation">,</span><span class="token parameter"> left</span><span class="token parameter punctuation">,</span><span class="token parameter"> right</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> value</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> left</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> right</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>用户对象既保存了数据，也保存了它的左节点和右节点的引用。</p><p>现在我们可以创建一个类，用来表示二叉查找树（BST），我们初始化类只包含一个成员，一个表示二叉查找树节点的 TreeNode 对象，初始化为 <code>null</code>，表示创建一个空节点。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="function BST() {
  // 根节点
  this.root = null;
}
" data-status="copy"></button><div class="token-line"><span class="token keyword">function</span><span class="token plain"> </span><span class="token constant">BST</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 根节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">root</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h3 id="插入操作"><a aria-hidden="true" href="#插入操作"><span class="icon icon-link"></span></a>插入操作</h3><p>二叉查找树中的基本操作是插入一个新节点。有许多不同的方法去插入新节点，这章节中，我们只讨论一种使整体操作变化最小的经典方法。 它的主要思想是为目标节点找出合适的叶节点位置，然后将该节点作为叶节点插入。</p><p>与搜索操作类似，对于每个节点，我们将：</p><ol><li>根据节点值与目标节点值的关系，搜索左子树或右子树；</li><li>重复步骤 1 直到到达外部节点；</li><li>根据节点的值与目标节点的值的关系，将新节点添加为其左侧或右侧的子节点。</li></ol><p>这样，我们就可以添加一个新的节点并依旧维持二叉查找树的性质。</p></div><img alt="二叉查找树-插入元素" src="/data-structure-and-algorithms-guidebook/static/binary-search-tree-insert.e43ad819.gif" width="40%" height="40%"/><div class="markdown"><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.insert = function(value) {
  // 首先要添加新的节点，首先需要创建 TreeNode 对象，将数据传入该对象
  const newNode = new TreeNode(value, null, null);

  // 其次要检查当前的 BST 树是否有根节点
  // 如果没有，那么表示这是一棵新树，插入节点就是该树的根节点，那么插入这个过程就结束了；否则进行下一步
  if (this.root === null) {
    this.root = newNode;
  } else {
    // 如果待插入节点不是根节点，那么必须对 BST 进行遍历，找到合适的位置
    // 该过程类似遍历链表，用一个变量存储当前变量，一层一层遍历 BST

    // 1. 设置当前节点为根节点
    let current = this.root,
      parent;

    while (true) {
      parent = current;

      // 2. 如果待插入节点保存的数据小于当前节点，则新节点为原节点的左子节点；反之执行第 4 步
      if (value &lt; current.value) {
        current = current.left;

        // 3. 如果当前节点的左子节点为空，则将新节点放到这个位置上，退出循环；反之继续执行下一步
        if (current === null) {
          parent.left = newNode;
          break;
        }
      } else {
        // 4. 设置新节点为原节点的右子节点
        current = current.right;

        // 5. 如果当前节点的右子节点为空，则将新节点放到这个位置上，退出循环；反之继续执行下一步
        if (current === null) {
          parent.right = newNode;
          break;
        }
      }
    }
  }
};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">insert</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 首先要添加新的节点，首先需要创建 TreeNode 对象，将数据传入该对象</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> newNode </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">new</span><span class="token plain"> </span><span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token plain">value</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 其次要检查当前的 BST 树是否有根节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 如果没有，那么表示这是一棵新树，插入节点就是该树的根节点，那么插入这个过程就结束了；否则进行下一步</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">root</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">root</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> newNode</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 如果待插入节点不是根节点，那么必须对 BST 进行遍历，找到合适的位置</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 该过程类似遍历链表，用一个变量存储当前变量，一层一层遍历 BST</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 1. 设置当前节点为根节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">let</span><span class="token plain"> current </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">root</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      parent</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      parent </span><span class="token operator">=</span><span class="token plain"> current</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token comment">// 2. 如果待插入节点保存的数据小于当前节点，则新节点为原节点的左子节点；反之执行第 4 步</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">value </span><span class="token operator">&lt;</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        current </span><span class="token operator">=</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token comment">// 3. 如果当前节点的左子节点为空，则将新节点放到这个位置上，退出循环；反之继续执行下一步</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">current </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">          parent</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> newNode</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">          </span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token comment">// 4. 设置新节点为原节点的右子节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        current </span><span class="token operator">=</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token comment">// 5. 如果当前节点的右子节点为空，则将新节点放到这个位置上，退出循环；反之继续执行下一步</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">current </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">          parent</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> newNode</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">          </span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>现在 BST 类已经初步成型，但操作仅仅限于插入节点，我们需要有遍历 BST 的能力。</p><h3 id="遍历操作"><a aria-hidden="true" href="#遍历操作"><span class="icon icon-link"></span></a>遍历操作</h3><h4 id="中序遍历"><a aria-hidden="true" href="#中序遍历"><span class="icon icon-link"></span></a>中序遍历</h4><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.inOrder = function(node) {
  if (!(node === null)) {
    this.inOrder(node.left);
    console.log(node.value + &#x27; &#x27;);
    this.inOrder(node.right);
  }
};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">inOrder</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token plain">node </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">inOrder</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token plain"> </span><span class="token operator">+</span><span class="token plain"> </span><span class="token string">&#x27; &#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">inOrder</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h4 id="先序遍历"><a aria-hidden="true" href="#先序遍历"><span class="icon icon-link"></span></a>先序遍历</h4><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.preOrder = function(node) {
  if (!(node === null)) {
    console.log(node.value + &#x27; &#x27;);
    this.preOrder(node.left);
    this.preOrder(node.right);
  }
};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">preOrder</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token plain">node </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token plain"> </span><span class="token operator">+</span><span class="token plain"> </span><span class="token string">&#x27; &#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">preOrder</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">preOrder</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h4 id="后序遍历"><a aria-hidden="true" href="#后序遍历"><span class="icon icon-link"></span></a>后序遍历</h4><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.postOrder = function(node) {
  if (!(node === null)) {
    this.postOrder(node.left);
    this.postOrder(node.right);
    console.log(node.value + &#x27; &#x27;);
  }
};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">postOrder</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token plain">node </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">postOrder</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">postOrder</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token plain"> </span><span class="token operator">+</span><span class="token plain"> </span><span class="token string">&#x27; &#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h3 id="搜索操作"><a aria-hidden="true" href="#搜索操作"><span class="icon icon-link"></span></a>搜索操作</h3><p>根据 BST 的特性，对于每个节点：</p><ul><li>如果目标值等于节点的值，则返回节点;</li><li>如果目标值小于节点的值，则继续在左子树中搜索;</li><li>如果目标值大于节点的值，则继续在右子树中搜索。</li></ul><p>在 BST 上查找给定值，需要比较给定值和当前节点保存的值大小，通过比较，就能确定给定值在不在当前节点，再根据 BST 的特点，向左或向右遍历。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.find = function(value) {
  let current = this.root;

  while (current != null) {
    if (value === current.value) {
      return current;
    } else if (value &gt; current.value) {
      current = current.right;
    } else {
      current = current.left;
    }
  }

  return null;
};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">find</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> current </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">root</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">current </span><span class="token operator">!=</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">value </span><span class="token operator">===</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token keyword">return</span><span class="token plain"> current</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">value </span><span class="token operator">&gt;</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      current </span><span class="token operator">=</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      current </span><span class="token operator">=</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>查找最小值：</p><p>遍历左子树，直到左子树的某个节点的左子节点为 <code>null</code> 时，该节点保存的即为最小值。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.getMin = function() {
  let current = this.root;

  while (!(current.left === null)) {
    current = current.left;
  }

  return current;
};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">getMin</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> current </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">root</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token plain">current</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    current </span><span class="token operator">=</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> current</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>查找最大值：</p><p>与查找最小值类似，遍历右子树，直到右子树的某个右子节点为 <code>null</code> 时，该节点保存的即为最大值。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.getMax = function() {
  let current = this.root;

  while (!(current.right === null)) {
    current = current.right;
  }

  return current;
};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">getMax</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> current </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">root</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token plain">current</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    current </span><span class="token operator">=</span><span class="token plain"> current</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> current</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>查找前驱节点：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.predecessor = function() {};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">predecessor</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>查找后继节点：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.successor = function() {};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">successor</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>查找大于等于目标值的最小值（向上取整）</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.ceil = function(key) {};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">ceil</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>查找小于等于目标值的最大值（向下取整）</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.floor = function(key) {};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">floor</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h3 id="删除操作"><a aria-hidden="true" href="#删除操作"><span class="icon icon-link"></span></a>删除操作</h3><p>从 BST 中删除节点的操作是最为复杂的，其复杂程度取决于删除的节点位置。如果待删除的节点没有子节点，那么非常简单。如果删除包含左子节点或者右子节点，就变得稍微有些复杂。如果删除包含两个节点的节点最为复杂。</p><p>我们采用递归方法，来完成复杂的操作.</p><ol><li>如果要删除的节点没有子节点，我们可以直接移除该节点。</li><li>如果要删除的节点有一个子节点，我们可以用其子节点作为替换。</li><li>如果要删除的节点有两个子节点，我们需要用其中序后继节点或者前驱节点来替换，再删除该节点。</li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="BST.prototype.remove = function(value) {
  this.removeNode(this.root, value);
};

BST.prototype.getSmallest = function(node) {
  if (node.left === null) {
    return node;
  } else {
    return this.getSmallest(node.left);
  }
};

BST.prototype.removeNode = function(node, value) {
  // 1. 首先判断当前节点是否包含待删除的数据值
  // 如果包含，则删除该节点
  // 如果不包含，则比较当前节点上的数据和待删除树的大小关系
  if (node === null) return null;

  if (value === node.value) {
    // 待删除节点没有子节点
    if (node.left === null &amp;&amp; node.right === null) {
      return null;
    }

    // 待删除节点没有左子节点
    if (node.left === null) {
      return node.right;
    }

    // 待删除节点没有右子节点
    if (node.right === null) {
      return node.left;
    }

    // 待删除节点有两个子节点
    // 需要找到待删除节点左子树中的最小值
    const minNode = this.getSmallest(node.right);
    // 将右子树最小值赋值给待删除节点
    node.value = minNode.value;
    // 删除右子树刚才找到的最小值的节点
    node.right = removeNode(node.right, minNode.value);

    return node;
  } else if (value &lt; node.value) {
    // 如果待删除的数据值小于当前节点的数据，则移至当前节点的左子节点继续比较
    node.left = this.removeNode(node.left, value);

    return node;
  } else {
    // 如果待删除的数据值大于当前节点的数据，则移至当前节点的右子节点继续比较
    node.right = this.remove(node.right, value);

    return node;
  }
};
" data-status="copy"></button><div class="token-line"><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">remove</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">removeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">root</span><span class="token punctuation">,</span><span class="token plain"> value</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">getSmallest</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">return</span><span class="token plain"> node</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">return</span><span class="token plain"> </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">getSmallest</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token class-name">BST</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">removeNode</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token parameter punctuation">,</span><span class="token parameter"> value</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 1. 首先判断当前节点是否包含待删除的数据值</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 如果包含，则删除该节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 如果不包含，则比较当前节点上的数据和待删除树的大小关系</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">node </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token keyword">return</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">value </span><span class="token operator">===</span><span class="token plain"> node</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 待删除节点没有子节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token plain"> </span><span class="token operator">&amp;&amp;</span><span class="token plain"> node</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token keyword">return</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 待删除节点没有左子节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token keyword">return</span><span class="token plain"> node</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 待删除节点没有右子节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token keyword">return</span><span class="token plain"> node</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 待删除节点有两个子节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 需要找到待删除节点左子树中的最小值</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">const</span><span class="token plain"> minNode </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">getSmallest</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 将右子树最小值赋值给待删除节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    node</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> minNode</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 删除右子树刚才找到的最小值的节点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    node</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">,</span><span class="token plain"> minNode</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">return</span><span class="token plain"> node</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">value </span><span class="token operator">&lt;</span><span class="token plain"> node</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 如果待删除的数据值小于当前节点的数据，则移至当前节点的左子节点继续比较</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    node</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">removeNode</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token punctuation">,</span><span class="token plain"> value</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">return</span><span class="token plain"> node</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 如果待删除的数据值大于当前节点的数据，则移至当前节点的右子节点继续比较</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    node</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">remove</span><span class="token punctuation">(</span><span class="token plain">node</span><span class="token punctuation">.</span><span class="token property-access">right</span><span class="token punctuation">,</span><span class="token plain"> value</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">return</span><span class="token plain"> node</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h2 id="特性"><a aria-hidden="true" href="#特性"><span class="icon icon-link"></span></a>特性</h2><h3 id="局限性"><a aria-hidden="true" href="#局限性"><span class="icon icon-link"></span></a>局限性</h3><p>同样的数据，不同的插入顺序，树的结果是不一样的，如下图所示：</p></div><img alt="二叉查找树-局限性" src="/data-structure-and-algorithms-guidebook/static/binary-search-tree-limitations.6b20c5fe.jpeg" width="50%"/><div class="markdown"><p>这就是二叉查找树存在的问题，它可能是极端的，并不总是像左侧永远是一个平衡的二叉树，如果我顺序化插入树的形状就如右侧所示，会退化成一个链表，试想如果我需要查找节点 40，在上图所示的树形中需要遍历完所有节点，相比于左侧时间性能会消耗一倍。</p><p>为了解决这一问题，可能需要一种平衡的二叉查找树，常用的实现方法有红黑树、AVL 树等。</p><h2 id="高度平衡的二叉查找树"><a aria-hidden="true" href="#高度平衡的二叉查找树"><span class="icon icon-link"></span></a>高度平衡的二叉查找树</h2><blockquote><p>树结构中的常见用语：</p><ul><li>节点的深度：从树的根节点到该节点的边数</li><li>节点的高度：该节点和叶子之间最长路径上的边数</li><li>树的高度：其根节点的高度</li></ul></blockquote><p>一个高度平衡的二叉查找树（<strong>平衡二叉查找树</strong>）是在插入和删除任何节点之后，可以自动保持其高度最小。也就是说，有 <code>N</code> 个节点的平衡二叉查找树，它的高度是 <code>logN</code>。并且，每个节点的两个子树的高度不会相差超过 1。</p><blockquote><p>为什么是 <code>log n</code> 呢？</p><ul><li>一个高度为 <code>h</code> 的二叉树 <code>2^0 + 2^1 + ... + 2^h = 2^(h+1) -1</code></li><li>换言之，一个有 <code>N</code> 个节点，且高度为 <code>h</code> 的二叉树：<code>N &lt;= 2^(h+1) - 1</code></li><li>所以：<code>h &gt;= [log2 N]</code></li></ul></blockquote><p>下面是一个普通二叉搜索树和一个高度平衡的二叉搜索树的例子:</p></div><img alt="普通二叉查找树和高度凭很二叉查找树" src="/data-structure-and-algorithms-guidebook/static/binary-search-tree-and-balanced-binary-search-tree.a0d29917.png" width="35%"/><div class="markdown"><p>根据定义，我们可以判断出一个二叉搜索树是否是高度平衡的 (平衡二叉树)。</p><p>正如我们之前提到的, 一个有 N 个节点的平衡二搜索叉树的高度总是 <code>logN</code>。因此，我们可以计算 <code>节点总数</code> 和 <code>树的高度</code>，以确定这个二叉搜索树是否为高度平衡的。</p><p>同样，在定义中， 我们提到了高度平衡的二叉树一个特性: 每个节点的两个子树的深度不会相差超过 1。我们也可以根据这个性质，递归地验证树。</p><h3 id="必要性"><a aria-hidden="true" href="#必要性"><span class="icon icon-link"></span></a>必要性</h3><blockquote><p>为什么需要用到高度平衡的二叉搜索树?</p></blockquote><p>我们已经介绍过了二叉树及其相关操作, 包括搜索、插入、删除。 当分析这些操作的时间复杂度时，我们需要注意的是树的高度是十分重要的考量因素。以搜索操作为例，如果二叉搜索树的高度为 <code>h</code>，则时间复杂度为 <code>O(h)</code>。二叉搜索树的高度的确很重要。</p><p>所以，我们来讨论一下树的节点总数 <code>N</code> 和高度 <code>h</code> 之间的关系。 对于一个平衡二叉搜索树, 我们已经在前文中提过 <code>h &gt;= [log2 N]</code>。但对于一个普通的二叉搜索树， 在最坏的情况下, 它可以退化成一个链。</p><p>因此，具有 <code>N</code> 个节点的二叉搜索树的高度在 <code>logN</code> 到 <code>N</code> 区间变化。也就是说，搜索操作的时间复杂度可以从 <code>logN</code> 变化到 <code>N</code>。这是一个巨大的性能差异。</p><p>所以说，高度平衡的二叉搜索树对提高性能起着重要作用。</p><h3 id="实现方式"><a aria-hidden="true" href="#实现方式"><span class="icon icon-link"></span></a>实现方式</h3><p>有许多不同的方法可以实现。尽管这些实现方法的细节有所不同，但他们有相同的目标:</p><ol><li>采用的数据结构应该满足二分查找属性和高度平衡属性。</li><li>采用的数据结构应该支持二叉查找树的基本操作，包括在 <code>O(logN)</code> 时间内的搜索、插入和删除，即使在最坏的情况下也是如此。</li></ol><p>我们提供了一个常见的的高度平衡二叉树列表供您参考：</p><ul><li>红黑树</li><li>AVL 树</li><li>伸展树（Splay Tree）</li><li>树堆</li></ul><h3 id="实际应用"><a aria-hidden="true" href="#实际应用"><span class="icon icon-link"></span></a>实际应用</h3><p>高度平衡的二叉搜索树在实际中被广泛使用，因为它可以在 <code>O(logN)</code> 时间复杂度内执行所有搜索、插入和删除操作。</p><p>平衡二叉搜索树的概念经常运用在 <code>Set</code> 和 <code>Map</code> 中。<code>Set</code> 和 <code>Map</code> 的原理相似。 我们将在下文中重点讨论 <code>Set</code> 这个数据结构。</p><blockquote><p>Set（集合）是另一种数据结构，它可以存储大量 key（键）而不需要任何特定的顺序或任何重复的元素。 它应该支持的基本操作是将新元素插入到 Set 中，并检查元素是否存在于其中。</p></blockquote><p>通常，有两种最广泛使用的集合：散列集合（Hash Set）和树集合（Tree Set）。</p><p>树集合, Java 中的 Treeset 或者 C++ 中的 set，是由高度平衡的二叉搜索树实现的。因此，搜索、插入和删除的时间复杂度都是 <code>O(logN)</code>。</p><p>散列集合, Java 中的 HashSet 或者 C++中的 u<code>nordered_set</code>，是由哈希实现的, 但是平衡二叉搜索树也起到了至关重要的作用。当存在具有相同哈希键的元素过多时，将花费 <code>O(N)</code> 时间复杂度来查找特定元素，其中 <code>N</code> 是具有相同哈希键的元素的数量。 通常情况下，使用高度平衡的二叉搜索树将把时间复杂度从 <code>O(N)</code> 改善到 <code>O(logN)</code>。</p><p>哈希集和树集之间的本质区别在于树集中的键是有序的。</p><hr/><p><strong>参考资料：</strong></p><ul><li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener noreferrer">维基百科：二叉查找树<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a href="https://www.jianshu.com/p/6a4b7f261e99" target="_blank" rel="noopener noreferrer">JS 中的算法与数据结构——二叉查找树（Binary Sort Tree）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/leetcode/edit/master/docs/data-structure/tree/binary-search-tree.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last Update: ">9/23/2020, 1:03:06 PM</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/data-structure-and-algorithms-guidebook/umi.js"></script>
    <script src="/data-structure-and-algorithms-guidebook/docs__data-structure__tree__binary-search-tree.md.js"></script>
  </body>
</html>
