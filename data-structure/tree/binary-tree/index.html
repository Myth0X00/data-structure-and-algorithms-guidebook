<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <link
      rel="stylesheet"
      href="/data-structure-and-algorithms-guidebook/umi.b538b811.css"
    />
    <script>
      window.routerBase = "/data-structure-and-algorithms-guidebook/";
    </script>
    <script>
      //! umi version: 3.2.9
    </script>
    <title>&#x4E8C;&#x53C9;&#x6811;</title>
  
</head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//">Data Structure and Algorithms Guidebook</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a><a href="/data-structure-and-algorithms-guidebook//algorithms">算法</a><a href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//"></a><h1>Data Structure and Algorithms Guidebook</h1><p>数据结构与算法完全知识体系</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms">算法</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a></li><li><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a></li><li><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array">数组</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/array"><span>数组</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/string"><span>字符串</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/hash-map"><span>哈希表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/pattern-match"><span>模式匹配</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/multiple-patterns-match"><span>多模式匹配</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/array/regex"><span>正则表达式</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list">线性表</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/linear-list"><span>线性表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/singly-linked-list"><span>单链表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/double-linked-list"><span>双链表</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/linear-list/circular-linked-list"><span>循环链表</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack">栈与队列</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/stack"><span>栈</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/queue"><span>队列</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/circular-queue"><span>循环队列</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/multiple-level-feedback-queue"><span>多级反馈队列</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/queue-and-stack/priority-queue"><span>优先队列</span></a></li></ul></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure/tree">树</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/tree"><span>树</span></a></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-tree"><span>二叉树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-search-tree"><span>二叉查找树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/avl-tree"><span>AVL 树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/red-black-tree"><span>红黑树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/b-tree"><span>B 树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/b-plus-tree"><span>B+ 树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/fenwick-tree"><span>索引二叉树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/heap"><span>堆</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/index-heap"><span>索引堆</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/treap"><span>树堆</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/disjoint-set"><span>并查集</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/segment-tree"><span>线段树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/splay-tree"><span>伸展树</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/trie-tree"><span>前缀树</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//data-structure/graph">图形</a><ul><li><a href="/data-structure-and-algorithms-guidebook//data-structure/graph/graph"><span>图</span></a></li></ul></li></ul></div></div><ul class="__dumi-default-layout-toc" role="slug-list"><li title="性质" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-tree#性质"><span>性质</span></a></li><li title="特殊类型" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-tree#特殊类型"><span>特殊类型</span></a></li><li title="满二叉树" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-tree#满二叉树"><span>满二叉树</span></a></li><li title="完全二叉树" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-tree#完全二叉树"><span>完全二叉树</span></a></li><li title="遍历" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-tree#遍历"><span>遍历</span></a></li><li title="前序遍历" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-tree#前序遍历"><span>前序遍历</span></a></li><li title="中序遍历" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-tree#中序遍历"><span>中序遍历</span></a></li><li title="后序遍历" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//data-structure/tree/binary-tree#后序遍历"><span>后序遍历</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="二叉树"><a aria-hidden="true" href="#二叉树"><span class="icon icon-link"></span></a>二叉树</h1><p>二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。通常分支被称作 <code>左子树</code> 或 <code>右子树</code>。二叉树的分支具有左右次序，不能随意颠倒。</p><p>树和二叉树的三个主要差别：</p><ul><li>树的节点个数至少为 1，而二叉树的节点个数可以为 0</li><li>树中的最大度数（节点数量）没有限制，而二叉树的节点的最大度数为 2</li><li>树的节点没有左右之分，而二叉树的节点有左右之分</li></ul><h2 id="性质"><a aria-hidden="true" href="#性质"><span class="icon icon-link"></span></a>性质</h2><ul><li>若二叉树的层次从 0 开始，则在二叉树的第 <code>i</code> 层至多有 <code>2^i</code> 个结点（<code>i &gt;= 0</code>）<ul><li><code>i = 1</code> 时，只有一个根节点 <code>2^(i - 1) = 2^ 0 = 1</code></li></ul></li><li>高度为 <code>k</code> 的二叉树最多有 <code>2^(k + 1) - 1</code> 个结点（<code>k&gt;=-1</code>）（空树的高度为 <code>-1</code>）<ul><li><code>i = 2</code> 时，<code>2^k - 1 = 2^2 - 1 = 3</code> 个节点</li></ul></li><li>对任何一棵二叉树，如果其叶子结点（度为 0）数为 <code>m</code>，度为 2 的结点数为 <code>n</code>, 则 <code>m = n + 1</code></li></ul><h2 id="特殊类型"><a aria-hidden="true" href="#特殊类型"><span class="icon icon-link"></span></a>特殊类型</h2></div><img alt="满二叉树和完全二叉树" src="/data-structure-and-algorithms-guidebook/static/complete-binary-tree-and-full-binary-tree.42727b4b.jpg" width="35%"/><div class="markdown"><h3 id="满二叉树"><a aria-hidden="true" href="#满二叉树"><span class="icon icon-link"></span></a>满二叉树</h3><p>上图编号 2 的二叉树中，叶子节点全部都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做 <strong>满二叉树</strong>（Full Binary Tree）。</p><p>满二叉树的性质：</p><ol><li>一棵树深度为 <code>h</code>，最大层数为 <code>k</code>，深度与最大层数相同 <code>k = h</code></li><li>叶子数为 <code>2^h</code></li><li>第 <code>k</code> 层的节点数是 <code>2^(k-1)</code></li><li>总节点数是 <code>2^(k - 1)</code>，且总节点数一定是奇数</li></ol><h3 id="完全二叉树"><a aria-hidden="true" href="#完全二叉树"><span class="icon icon-link"></span></a>完全二叉树</h3><p>上图编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都达到最大，这种二叉树叫做 <strong>完全二叉树</strong>（Complete Binary Tree）。</p><p>完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra 算法、Prim 算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。</p><p>以上两种特殊类型的二叉树都能通过公式计算总节点和树高。</p><table><thead><tr><th align="left"></th><th align="left">满二叉树</th><th align="left">完全二叉树</th></tr></thead><tbody><tr><td align="left">总节点 k</td><td align="left"><code>2^(h - 1) &lt;= k &lt;= 2^h - 1</code></td><td align="left"><code>k = 2^h - 1</code></td></tr><tr><td align="left">树高 h</td><td align="left"><code>h = log2 k + 1</code></td><td align="left"><code>h = log2(k + 1)</code></td></tr></tbody></table><h2 id="遍历"><a aria-hidden="true" href="#遍历"><span class="icon icon-link"></span></a>遍历</h2><ul><li><strong>中序遍历</strong>：即 <code>左-根-右</code> 遍历，对于给定的二叉树根，寻找其左子树；对于其左子树的根，再去寻找其左子树；递归遍历，直到寻找最左边的节点 <code>i</code>，其必然为叶子，然后遍历 <code>i</code> 的父节点，再遍历 <code>i</code> 的兄弟节点。随着递归的逐渐出栈，最终完成遍历：</li><li><strong>先序遍历</strong>：即 <code>根-左-右</code> 遍历</li><li><strong>后序遍历</strong>：即 <code>左-右-根</code> 遍历</li></ul><p>实际上，二叉树的前、中、后序遍历就是一个递归的过程。</p></div><img alt="二叉树的遍历" src="/data-structure-and-algorithms-guidebook/static/binary-tree-iteration.561b1f45.jpg" width="50%"/><div class="markdown"><h3 id="前序遍历"><a aria-hidden="true" href="#前序遍历"><span class="icon icon-link"></span></a>前序遍历</h3><p>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p><h3 id="中序遍历"><a aria-hidden="true" href="#中序遍历"><span class="icon icon-link"></span></a>中序遍历</h3><p>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。</p><p>通常来说，对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列。</p><h3 id="后序遍历"><a aria-hidden="true" href="#后序遍历"><span class="icon icon-link"></span></a>后序遍历</h3><p>后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。</p><p>值得注意的是，当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。</p><p>另外，后序在数学表达中被广泛使用。 编写程序来解析后缀表示法更为容易。 这里是一个例子：</p><p>您可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。</p><p>如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。</p><hr/><p><strong>参考资料：</strong></p><ul><li><a href="https://www.cnblogs.com/maybe2030/p/4732377.html" target="_blank" rel="noopener noreferrer">数据结构中各种树<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a href="https://charlesliuyx.github.io/2018/10/22/%E3%80%90%E7%9B%B4%E8%A7%82%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="noopener noreferrer">二叉树遍历算法总结<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/leetcode/edit/master/docs/data-structure/tree/binary-tree.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last Update: ">7/12/2020, 4:55:03 PM</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/data-structure-and-algorithms-guidebook/umi.d9db81cf.js"></script>
    <script src="/data-structure-and-algorithms-guidebook/docs__data-structure__tree__binary-tree.md.6d0b326a.async.js"></script>
  </body>
</html>
