<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <link
      rel="stylesheet"
      href="/data-structure-and-algorithms-guidebook/umi.css"
    />
    <script>
      window.routerBase = "/data-structure-and-algorithms-guidebook/";
    </script>
    <script>
      //! umi version: 3.2.22
    </script>
    <title>归并排序</title>
  
</head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//">Data Structure and Algorithms Guidebook</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><a href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//algorithms">算法</a><a href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//"></a><h1>Data Structure and Algorithms Guidebook</h1><p>数据结构与算法完全知识体系</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//algorithms">算法</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a></li><li><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a></li><li><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a href="/data-structure-and-algorithms-guidebook//algorithms/basic">算法基础</a><ul><li><a href="/data-structure-and-algorithms-guidebook//algorithms/basic/complexity"><span>算法复杂度</span></a></li></ul></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//algorithms/sorting">排序</a><ul><li><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/sorting"><span>排序概述</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/bubble-sort"><span>冒泡排序</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/selection-sort"><span>选择排序</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/insertion-sort"><span>插入排序</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/shell-sort"><span>希尔排序</span></a></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//algorithms/sorting/merge-sort"><span>归并排序</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/quick-sort"><span>快速排序</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/heap-sort"><span>堆排序</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/counting-sort"><span>计数排序</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/bucket-sort"><span>桶排序</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/radix-sort"><span>基数排序</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/search">搜索</a><ul><li><a href="/data-structure-and-algorithms-guidebook//algorithms/search/binary-search"><span>二分查找法</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/search/dfs"><span>深度优先搜索</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/search/bfs"><span>广度优先搜索</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/search/kmp"><span>KMP 算法</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms-idea">算法思想</a><ul><li><a href="/data-structure-and-algorithms-guidebook//algorithms-idea/greedy-algorithm"><span>贪心算法</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms-idea/divide-and-conquer-algorithm"><span>分治算法</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms-idea/backtracking"><span>回溯算法</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms-idea/dynamic-programming"><span>动态规划</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms-idea/backpack"><span>背包问题</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/summary">算法技巧总结</a><ul><li><a href="/data-structure-and-algorithms-guidebook//algorithms/summary/array"><span>数组解题技巧</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/summary/string"><span>字符串解题技巧</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/summary/linked-list"><span>链表解题技巧</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/summary/binary-tree"><span>二叉树解题技巧</span></a></li></ul></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/other">Other</a><ul><li><a href="/data-structure-and-algorithms-guidebook//algorithms/other/prefix-sum"><span>前缀和</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/other/recursion"><span>递归</span></a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms/other/union-find"><span>并查集</span></a></li></ul></li></ul></div></div><ul class="__dumi-default-layout-toc" role="slug-list"><li title="算法原理" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/merge-sort#算法原理"><span>算法原理</span></a></li><li title="迭代法" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/merge-sort#迭代法"><span>迭代法</span></a></li><li title="递归法" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/merge-sort#递归法"><span>递归法</span></a></li><li title="算法分析" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/merge-sort#算法分析"><span>算法分析</span></a></li><li title="算法实现" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//algorithms/sorting/merge-sort#算法实现"><span>算法实现</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="归并排序"><a aria-hidden="true" href="#归并排序"><span class="icon icon-link"></span></a>归并排序</h1><p><strong>归并排序</strong>（Merge sort）是建立在归并操作上的一种有效的排序算法。</p><p>该算法是采用 <strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）</li><li>自下而上的迭代</li></ul><h2 id="算法原理"><a aria-hidden="true" href="#算法原理"><span class="icon icon-link"></span></a>算法原理</h2><p>归并排序是用分治思想，分治模式在每层递归上有三个步骤：</p><ul><li><strong>分解</strong>（Divide）：将 <code>n</code> 个元素分成含 <code>n / 2</code> 个元素的子序列</li><li><strong>解决</strong>（Comquer）：用合并排序法对两个子序列递归的排序</li><li><strong>合并</strong>（Combine）：合并两个已排序的子序列已得到排序结果</li></ul><h3 id="迭代法"><a aria-hidden="true" href="#迭代法"><span class="icon icon-link"></span></a>迭代法</h3><ol><li>申请<strong>临时空间</strong>，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤 3 直到某一指针达到序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><h3 id="递归法"><a aria-hidden="true" href="#递归法"><span class="icon icon-link"></span></a>递归法</h3><ol><li>将序列每相邻两个数字进行归并操作，形成 <code>Math.floor(n / 2)</code> 个序列，排序后每个序列包含两个元素</li><li>将上述序列再次归并，形成 <code>Math.floor(n / 4)</code> 个序列，每个序列包含四个元素</li><li>重复步骤 2，直到所有元素排序完毕</li></ol></div><img alt="归并排序" src="/data-structure-and-algorithms-guidebook/static/merge-sort.2f9d7fcc.gif" width="45%" height="45%"/><div class="markdown"><h2 id="算法分析"><a aria-hidden="true" href="#算法分析"><span class="icon icon-link"></span></a>算法分析</h2><ul><li>平均时间复杂度：<code>O(nlogn)</code></li><li>最佳时间复杂度：<code>O(n)</code></li><li>最差时间复杂度：<code>O(nlogn)</code></li><li>空间复杂度：<code>O(n)</code></li><li>排序方式：In-place</li><li>稳定性：稳定</li></ul><p>不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：<code>O( nlogn )</code></p><p>归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：<code>n + logn</code>；所以空间复杂度为: <code>O(n)</code>。</p><p>归并排序算法中，归并最后到底都是相邻元素之间的比较交换，并不会发生相同元素的相对位置发生变化，故是稳定性算法。</p></div><img alt="归并排序" src="/data-structure-and-algorithms-guidebook/static/merge-sort.5ab24a39.png" width="70%" height="70%"/><div class="markdown"><h2 id="算法实现"><a aria-hidden="true" href="#算法实现"><span class="icon icon-link"></span></a>算法实现</h2><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="// 采用自上而下的递归方法

// 分（切割）
function mergeSort(arr) {
  let len = arr.length;

  // 当分裂到数组元素仅存一个或没有时，表示无法再继续分裂了
  // 则返回数组进行归并
  if (len &lt;= 1) {
    return arr;
  }

  // 计算切割点
  let mid = Math.floor(len / 2),
    // 递归切割左子数组，然后归并为有序数组
    left = mergeSort(arr.slice(0, mid)),
    // 递归切割右子数组，然后归并为有序数组
    right = mergeSort(arr.slice(mid));

  return merge(left, right);
}

// 治（归并）
function merge(left, right) {
  let sorted = [];

  while (left.length &amp;&amp; right.length) {
    if (left[0] &lt;= right[0]) {
      // 左边数组首个元素比右边数组首个元素小
      // 将左边数组首个元素推出原数组，并推入已排序数组
      sorted.push(left.shift());
    } else {
      // 右边数组首个元素比左边数组首个元素小
      // 将有边数组首个元素推出原数组，并推入已排序数组
      sorted.push(right.shift());
    }
  }

  // 走到这步，说明某边数组已经空了
  // 所以如果另一边数组还有一个元素，则直接推出原数组，并推入已排序数组
  while (left.length) sorted.push(left.shift());
  while (right.length) sorted.push(right.shift());

  return sorted;
}
" data-status="copy"></button><div class="token-line"><span class="token comment">// 采用自上而下的递归方法</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 分（切割）</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> len </span><span class="token operator">=</span><span class="token plain"> arr</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 当分裂到数组元素仅存一个或没有时，表示无法再继续分裂了</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 则返回数组进行归并</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">len </span><span class="token operator">&lt;=</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">return</span><span class="token plain"> arr</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 计算切割点</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> mid </span><span class="token operator">=</span><span class="token plain"> </span><span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">floor</span><span class="token punctuation">(</span><span class="token plain">len </span><span class="token operator">/</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 递归切割左子数组，然后归并为有序数组</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    left </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token plain">arr</span><span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token plain"> mid</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token comment">// 递归切割右子数组，然后归并为有序数组</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    right </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token plain">arr</span><span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">(</span><span class="token plain">mid</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> </span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token plain">left</span><span class="token punctuation">,</span><span class="token plain"> right</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 治（归并）</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">left</span><span class="token parameter punctuation">,</span><span class="token parameter"> right</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> sorted </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">left</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token plain"> </span><span class="token operator">&amp;&amp;</span><span class="token plain"> right</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">left</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token operator">&lt;=</span><span class="token plain"> right</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token comment">// 左边数组首个元素比右边数组首个元素小</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token comment">// 将左边数组首个元素推出原数组，并推入已排序数组</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      sorted</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token plain">left</span><span class="token punctuation">.</span><span class="token method function property-access">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token comment">// 右边数组首个元素比左边数组首个元素小</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token comment">// 将有边数组首个元素推出原数组，并推入已排序数组</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      sorted</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token plain">right</span><span class="token punctuation">.</span><span class="token method function property-access">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 走到这步，说明某边数组已经空了</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 所以如果另一边数组还有一个元素，则直接推出原数组，并推入已排序数组</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">left</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token plain"> sorted</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token plain">left</span><span class="token punctuation">.</span><span class="token method function property-access">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">right</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token plain"> sorted</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token plain">right</span><span class="token punctuation">.</span><span class="token method function property-access">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> sorted</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><blockquote><p>如果我们有两个已经排序好的数组，如何将他们归并成一个数组？</p></blockquote><p>我们可以开辟一个临时数组来辅助我们的归并，也就是说他比我们插入排序也好，选择排序也好多使用了存储的空间，也就是说他需要 <code>O(n)</code> 的额外空间来完成这个排序。只不过现在计算机中时间的效率要比空间的效率重要得多。无论是内存也好还是硬盘也好可以存储的数据越来越多，所以设计一个算法，时间复杂度是要优先考虑的。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/leetcode/edit/master/docs/algorithms/sorting/merge-sort.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last Update: ">9/23/2020, 1:03:06 PM</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/data-structure-and-algorithms-guidebook/umi.js"></script>
    <script src="/data-structure-and-algorithms-guidebook/docs__algorithms__sorting__merge-sort.md.js"></script>
  </body>
</html>
