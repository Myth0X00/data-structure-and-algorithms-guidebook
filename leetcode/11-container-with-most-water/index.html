<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <link
      rel="stylesheet"
      href="/data-structure-and-algorithms-guidebook/umi.b538b811.css"
    />
    <script>
      window.routerBase = "/data-structure-and-algorithms-guidebook/";
    </script>
    <script>
      //! umi version: 3.2.9
    </script>
    <title>11 - &#x76DB;&#x6700;&#x591A;&#x6C34;&#x7684;&#x5BB9;&#x5668;</title>
  
</head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//">Data Structure and Algorithms Guidebook</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><a href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a><a href="/data-structure-and-algorithms-guidebook//algorithms">算法</a><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//"></a><h1>Data Structure and Algorithms Guidebook</h1><p>数据结构与算法完全知识体系</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms">算法</a></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a></li><li><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a></li><li><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a href="/data-structure-and-algorithms-guidebook//leetcode/1-two-sum">1 - 两数之和</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/2-add-two-numbers">2 - 两数相加</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/5-longest-palindromic-substring">5 - 最长回文子串</a></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//leetcode/11-container-with-most-water">11 - 盛最多水的容器</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/14-longest-common-prefix">14 - 最长公共前缀</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/15-three-sum">15 - 三数之和</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/19-remove-nth-node-from-end-of-list">19 - 删除链表的倒数第 N 个节点</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/20-valid-parentheses">20 - 有效的括号</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/21-merge-two-sorted-lists">21 - 合并两个有序链表</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/35-search-insert-position">35 - 搜索插入位置</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/141-linked-list-cycle">141 - 环形链表</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/142-linked-list-cycle-ii">142 - 环形链表 II</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/150-evaluate-reverse-polish-notation">150 - 逆波兰表达式求值</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/155-min-stack">155 - 最小栈</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/160-intersection-of-two-linked-lists">160 - 相交链表</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/206-reverse-linked-list">206 - 反转链表</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/234-palindrome-linked-list">234 - 回文链表</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/328-odd-even-linked-list">238 - 奇偶链表</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/622-design-circular-queue">622 - 设计循环队列</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/724-find-pivot-index">724 - 寻找数组的中心索引</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/739-daily-temperatures">739 - 每日温度</a></li></ul></div></div><ul class="__dumi-default-layout-toc" role="slug-list"><li title="解题思路" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//leetcode/11-container-with-most-water#解题思路"><span>解题思路</span></a></li><li title="暴力法" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//leetcode/11-container-with-most-water#暴力法"><span>暴力法</span></a></li><li title="双指针法" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//leetcode/11-container-with-most-water#双指针法"><span>双指针法</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="盛最多水的容器"><a aria-hidden="true" href="#盛最多水的容器"><span class="icon icon-link"></span></a>盛最多水的容器</h1><p>给你 <code>n</code> 个非负整数 <code>a1</code>，<code>a2</code>，...，<code>an</code>，每个数代表坐标中的一个点  <code>(i, ai)</code> 。在坐标内画 <code>n</code> 条垂直线，垂直线 <code>i</code>  的两个端点分别为  <code>(i, ai)</code> 和 <code>(i, 0)</code>。找出其中的两条线，使得它们与  <code>x</code>  轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且  <code>n</code>  的值至少为 2。</p></div><img alt="盛最多水的容器" src="/data-structure-and-algorithms-guidebook/static/question-11.9756eeab.jpg" width="50%" height="50%"/><div class="markdown"><h2 id="解题思路"><a aria-hidden="true" href="#解题思路"><span class="icon icon-link"></span></a>解题思路</h2><h3 id="暴力法"><a aria-hidden="true" href="#暴力法"><span class="icon icon-link"></span></a>暴力法</h3><p>考虑每对可能出现的线段组合并找出这些情况下的最大面积。</p><h4 id="复杂度分析"><a aria-hidden="true" href="#复杂度分析"><span class="icon icon-link"></span></a>复杂度分析</h4><ul><li>时间复杂度：<code>O(n2)</code>，计算所有 <code>n(n-1)/2</code> 种高度组合的面积</li><li>空间：<code>O(1)</code>，使用恒定的额外空间</li></ul><h3 id="双指针法"><a aria-hidden="true" href="#双指针法"><span class="icon icon-link"></span></a>双指针法</h3><p>我们先从题目中的示例开始，一步一步地解释双指针算法的过程。稍后再给出算法正确性的证明。</p><p>题目中的示例为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-plain"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="[1, 8, 6, 2, 5, 4, 8, 3, 7]
 ^                       ^
" data-status="copy"></button><div class="token-line"><span class="token plain">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span></div><div class="token-line"><span class="token plain"> ^                       ^</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>在初始时，左右指针分别指向数组的左右两端，它们可以容纳的水量为 <code>min(1, 7) * 8 = 8</code>。</p><p>此时我们需要移动一个指针。移动哪一个呢？直觉告诉我们，应该移动对应数字较小的那个指针（即此时的左指针）。这是因为，由于容纳的水量是由</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="两个指针指向的数字中较小值 ∗ 指针之间的距离
" data-status="copy"></button><div class="token-line"><span class="token plain">两个指针指向的数字中较小值 ∗ 指针之间的距离</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>决定的。如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 <strong>数字较小的那个指针</strong>。</p><blockquote><p>有读者可能会产生疑问：我们可不可以同时移动两个指针？ 先别急，我们先假设 总是移动数字较小的那个指针 的思路是正确的，在走完流程之后，我们再去进行证明。</p></blockquote><p>所以，我们将左指针向右移动：</p><div class="__dumi-default-code-block"><pre class="prism-code language-plain"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^                    ^
" data-status="copy"></button><div class="token-line"><span class="token plain">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span></div><div class="token-line"><span class="token plain">    ^                    ^</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>此时可以容纳的水量为 <code>min(8, 7) * 7 = 49</code>。由于右指针对应的数字较小，我们移动右指针：</p><div class="__dumi-default-code-block"><pre class="prism-code language-plain"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^                 ^
" data-status="copy"></button><div class="token-line"><span class="token plain">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span></div><div class="token-line"><span class="token plain">    ^                 ^</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>此时可以容纳的水量为 <code>min(8, 3) \* 6 = 18</code>。由于右指针对应的数字较小，我们移动右指针：</p><div class="__dumi-default-code-block"><pre class="prism-code language-plain"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^              ^
" data-status="copy"></button><div class="token-line"><span class="token plain">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span></div><div class="token-line"><span class="token plain">    ^              ^</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>此时可以容纳的水量为 <code>min(8, 8) \* 5 = 40</code>。两指针对应的数字相同，我们可以任意移动一个，例如左指针：</p><div class="__dumi-default-code-block"><pre class="prism-code language-plain"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="[1, 8, 6, 2, 5, 4, 8, 3, 7]
       ^           ^
" data-status="copy"></button><div class="token-line"><span class="token plain">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span></div><div class="token-line"><span class="token plain">       ^           ^</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>此时可以容纳的水量为 <code>min(6, 8) * 4 = 24</code>。由于左指针对应的数字较小，我们移动左指针，并且可以发现，在这之后左指针对应的数字总是较小，因此我们会一直移动左指针，直到两个指针重合。在这期间，对应的可以容纳的水量为：<code>min(2, 8) * 3 = 6</code>，<code>min(5, 8) * 2 = 10</code>，<code>min(4, 8) * 1 = 4</code>。</p><p>在我们移动指针的过程中，计算到的最多可以容纳的数量为 49，即为最终的答案。</p><h4 id="证明"><a aria-hidden="true" href="#证明"><span class="icon icon-link"></span></a>证明</h4><p>为什么双指针的做法是正确的？</p><blockquote><p>双指针代表了什么？</p></blockquote><p>双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，因为我们还没有进行过任何尝试。在这之后，我们每次将 对应的数字较小的那个指针 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了。</p><blockquote><p>为什么对应的数字较小的那个指针不可能再作为容器的边界了？</p></blockquote><p>在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。</p><p><strong>考虑第一步</strong>，假设当前左指针和右指针指向的数分别为 <code>x</code> 和 <code>y</code>，不失一般性，我们假设 <code>x ≤ y</code>。同时，两个指针之间的距离为 <code>t</code>。那么，它们组成的容器的容量为：<code>min(x, y) ∗ t = x ∗ t</code>。</p><p>我们可以断定，<strong>如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 <code>x * t</code> 了</strong>。注意这里右指针只能向左移动，因为 <strong>我们考虑的是第一步</strong>，也就是 <strong>指针还指向数组的左右边界的时候</strong>。</p><p>我们任意向左移动右指针，指向的数为 <code>y1</code>，两个指针之间的距离为 <code>t1</code>，那么显然有 <code>t1 &lt; t</code>，并且 <code>min(x,y1) ≤ min(x,y)</code>：</p><ul><li>如果 <code>y1 ≤ y</code>，那么 <code>min(x, y1) ≤ min(x, y)</code>；</li><li>如果 <code>y1 &gt; y</code>，那么 <code>min(x, y1) = x = min(x, y)</code>。</li></ul><p>因此有：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="min(x, y[t]) ∗ t1 &lt; min(x, y) ∗ t
" data-status="copy"></button><div class="token-line"><span class="token function">min</span><span class="token punctuation">(</span><span class="token plain">x</span><span class="token punctuation">,</span><span class="token plain"> y</span><span class="token punctuation">[</span><span class="token plain">t</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token plain"> ∗ t1 </span><span class="token operator">&lt;</span><span class="token plain"> </span><span class="token function">min</span><span class="token punctuation">(</span><span class="token plain">x</span><span class="token punctuation">,</span><span class="token plain"> y</span><span class="token punctuation">)</span><span class="token plain"> ∗ t</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。</p><p>这样以来，我们将问题的规模减小了 <code>1</code>，被我们丢弃的那个位置就相当于消失了。此时的左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界，因此，我们可以继续像之前 考虑第一步 那样考虑这个问题：</p><p>求出当前双指针对应的容器的容量；</p><p>对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。</p><blockquote><p>最后的答案是什么？</p></blockquote><p>答案就是我们每次以双指针为左右边界（也就是「数组」的左右边界）计算出的容量中的最大值。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="const maxArea = function(height) {
  let l = 0;
  let r = height.length - 1;
  let max = 0;

  while (l &lt; r) {
    max = Math.max(max, (r - 1) * Math.min(height[l], height[r]));
    if (height[l] &lt; height[r]) {
      l++;
    } else {
      r--;
    }
  }

  return max;
};
" data-status="copy"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> </span><span class="token function-variable function">maxArea</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">height</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> l </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">0</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> r </span><span class="token operator">=</span><span class="token plain"> height</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token plain"> </span><span class="token operator">-</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> max </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">0</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">l </span><span class="token operator">&lt;</span><span class="token plain"> r</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    max </span><span class="token operator">=</span><span class="token plain"> </span><span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">max</span><span class="token punctuation">(</span><span class="token plain">max</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">r </span><span class="token operator">-</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token operator">*</span><span class="token plain"> </span><span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">min</span><span class="token punctuation">(</span><span class="token plain">height</span><span class="token punctuation">[</span><span class="token plain">l</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token plain"> height</span><span class="token punctuation">[</span><span class="token plain">r</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">height</span><span class="token punctuation">[</span><span class="token plain">l</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token operator">&lt;</span><span class="token plain"> height</span><span class="token punctuation">[</span><span class="token plain">r</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      l</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      r</span><span class="token operator">--</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> max</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h4 id="复杂度分析-1"><a aria-hidden="true" href="#复杂度分析-1"><span class="icon icon-link"></span></a>复杂度分析</h4><ul><li>时间复杂度：<code>O(n)</code>，双指针总计最多遍历整个数组一次。</li><li>空间复杂度：<code>O(1)</code>，只需要额外的常数级别的空间。</li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/leetcode/edit/master/docs/leetcode/11-container-with-most-water.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last Update: ">7/12/2020, 4:55:03 PM</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/data-structure-and-algorithms-guidebook/umi.d9db81cf.js"></script>
    <script src="/data-structure-and-algorithms-guidebook/docs__leetcode__11-container-with-most-water.md.22e71ace.async.js"></script>
  </body>
</html>
