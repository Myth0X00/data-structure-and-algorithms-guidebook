<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <link
      rel="stylesheet"
      href="/data-structure-and-algorithms-guidebook/umi.css"
    />
    <script>
      window.routerBase = "/data-structure-and-algorithms-guidebook/";
    </script>
    <script>
      //! umi version: 3.2.20
    </script>
    <title>35 - 搜索插入位置</title>
  
</head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//">Data Structure and Algorithms Guidebook</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><a href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a><a href="/data-structure-and-algorithms-guidebook//algorithms">算法</a><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/data-structure-and-algorithms-favicon.svg&#x27;)" href="/data-structure-and-algorithms-guidebook//"></a><h1>Data Structure and Algorithms Guidebook</h1><p>数据结构与算法完全知识体系</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a href="/data-structure-and-algorithms-guidebook//data-structure">数据结构</a></li><li><a href="/data-structure-and-algorithms-guidebook//algorithms">算法</a></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//leetcode">LeetCode</a></li><li><a href="/data-structure-and-algorithms-guidebook//front-end">前端编程</a></li><li><a href="/data-structure-and-algorithms-guidebook//extensions">扩展</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/data-structure-and-algorithms-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a href="/data-structure-and-algorithms-guidebook//leetcode/1-two-sum">1 - 两数之和</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/2-add-two-numbers">2 - 两数相加</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/5-longest-palindromic-substring">5 - 最长回文子串</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/11-container-with-most-water">11 - 盛最多水的容器</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/14-longest-common-prefix">14 - 最长公共前缀</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/15-three-sum">15 - 三数之和</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/19-remove-nth-node-from-end-of-list">19 - 删除链表的倒数第 N 个节点</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/20-valid-parentheses">20 - 有效的括号</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/21-merge-two-sorted-lists">21 - 合并两个有序链表</a></li><li><a aria-current="page" class="active" href="/data-structure-and-algorithms-guidebook//leetcode/35-search-insert-position">35 - 搜索插入位置</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/141-linked-list-cycle">141 - 环形链表</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/142-linked-list-cycle-ii">142 - 环形链表 II</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/150-evaluate-reverse-polish-notation">150 - 逆波兰表达式求值</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/155-min-stack">155 - 最小栈</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/160-intersection-of-two-linked-lists">160 - 相交链表</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/206-reverse-linked-list">206 - 反转链表</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/234-palindrome-linked-list">234 - 回文链表</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/328-odd-even-linked-list">238 - 奇偶链表</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/622-design-circular-queue">622 - 设计循环队列</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/724-find-pivot-index">724 - 寻找数组的中心索引</a></li><li><a href="/data-structure-and-algorithms-guidebook//leetcode/739-daily-temperatures">739 - 每日温度</a></li></ul></div></div><ul class="__dumi-default-layout-toc" role="slug-list"><li title="解题思路" data-depth="2" class=""><a href="/data-structure-and-algorithms-guidebook//leetcode/35-search-insert-position#解题思路"><span>解题思路</span></a></li><li title="暴力法" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//leetcode/35-search-insert-position#暴力法"><span>暴力法</span></a></li><li title="二分查找" data-depth="3" class=""><a href="/data-structure-and-algorithms-guidebook//leetcode/35-search-insert-position#二分查找"><span>二分查找</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="搜索插入位置"><a aria-hidden="true" href="#搜索插入位置"><span class="icon icon-link"></span></a>搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1：</p><div class="__dumi-default-code-block"><pre class="prism-code language-plain"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="输入: [1,3,5,6], 5
输出: 2
" data-status="copy"></button><div class="token-line"><span class="token plain">输入: [1,3,5,6], 5</span></div><div class="token-line"><span class="token plain">输出: 2</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>示例 2：</p><div class="__dumi-default-code-block"><pre class="prism-code language-plain"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="输入: [1,3,5,6], 2
输出: 1
" data-status="copy"></button><div class="token-line"><span class="token plain">输入: [1,3,5,6], 2</span></div><div class="token-line"><span class="token plain">输出: 1</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>示例 3：</p><div class="__dumi-default-code-block"><pre class="prism-code language-plain"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="输入: [1,3,5,6], 7
输出: 4
" data-status="copy"></button><div class="token-line"><span class="token plain">输入: [1,3,5,6], 7</span></div><div class="token-line"><span class="token plain">输出: 4</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>示例 4：</p><div class="__dumi-default-code-block"><pre class="prism-code language-plain"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="输入: [1,3,5,6], 0
输出: 0
" data-status="copy"></button><div class="token-line"><span class="token plain">输入: [1,3,5,6], 0</span></div><div class="token-line"><span class="token plain">输出: 0</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h2 id="解题思路"><a aria-hidden="true" href="#解题思路"><span class="icon icon-link"></span></a>解题思路</h2><h3 id="暴力法"><a aria-hidden="true" href="#暴力法"><span class="icon icon-link"></span></a>暴力法</h3><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="var searchInsert = function(nums, target) {
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] &gt;= target) {
      return i;
    }
  }
  return nums.length;
};
" data-status="copy"></button><div class="token-line"><span class="token keyword">var</span><span class="token plain"> </span><span class="token function-variable function">searchInsert</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token parameter punctuation">,</span><span class="token parameter"> target</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">for</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token keyword">let</span><span class="token plain"> i </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">0</span><span class="token punctuation">;</span><span class="token plain"> i </span><span class="token operator">&lt;</span><span class="token plain"> nums</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span><span class="token plain"> i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">nums</span><span class="token punctuation">[</span><span class="token plain">i</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token operator">&gt;=</span><span class="token plain"> target</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token keyword">return</span><span class="token plain"> i</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> nums</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h4 id="复杂度分析"><a aria-hidden="true" href="#复杂度分析"><span class="icon icon-link"></span></a>复杂度分析</h4><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O()</code></li></ul><h3 id="二分查找"><a aria-hidden="true" href="#二分查找"><span class="icon icon-link"></span></a>二分查找</h3><ul><li><strong>通常写二分法是奔着目标元素写的</strong></li></ul><p>通常教科书上给出的二分查找代码，循环部分给出的条件是 <code>while (left &lt;= right)</code> ，表示当 <code>left == right</code> 成立的时候，还有一个元素，即索引 <code>left</code>（<code>right</code>）位置的元素还没有看到，需要继续查看这个元素的值，看看是不是我们想要的。</p><p>这个思路把待查找数组分为了 3 个部分：<code>mid</code> 所在位置，<code>mid</code> 的左边，<code>mid</code> 的右边，根据 <code>mid</code> 元素与目标元素的值的大小关系，如果 <code>nums[mid]</code> 恰好等于 <code>target</code> 直接返回就好了，否则根据不等关系，确定下一轮搜索的区间在哪里。</p><p>「力扣」上有些二分题用这种思路做，有的时候往往会顺带思考很多问题，增加了出错率：例如</p><ol><li>返回 <code>left</code> 还是 <code>right</code>；</li><li>明明已经看到了等于 <code>target</code> 的元素，但是题目要求返回小于等于 <code>target</code> 的第 1 个元素的位置，或则要求返回大于等于 <code>target</code> 的最后 1 个元素的位置的时候，一不小心会把代码写成线性查找。</li></ol><p>这两个问题有时会增加思考问题的负担，一不小心还有可能出错。这一类问题的共同特点是：目标值往往在待查找数组中存在多个，但是题目要求我们返回的是一个边界值。</p><ul><li><strong>不妨从哪些元素一定不是目标元素考虑</strong></li></ul><p>做对这一类问题的思路是 <code>排除法</code>，在本题解最开始其实已经介绍了，我们的思路是做排除法：具体是根据看到的 <code>mid</code> 位置的元素，排除掉不可能存在目标元素的区间，而下一轮在可能存在目标的子区间里查找。</p><p>具体做法是：</p><ol><li>先把循环可以继续的条件写成 <code>while (left &lt; right)</code>。</li></ol><p>在循环的过程中 left 不断右移，right 不断左移。从形式上看，退出循环的时候一定有 <code>left == right</code> 成立。此时要注意：left （right） 这个位置的值可能程序还没有读取到，因此“有可能”需要再对 left（right） 这个位置的值是否是目标元素的值做一次判断。</p><ol start="2"><li>写 <code>if</code> 和 <code>else</code> 语句的时候，思考当 <code>nums[mid]</code> 满足什么性质的时候，<code>mid</code> 不是解，进而接着判断 <code>mid</code> 的左边有没有可能是解，<code>mid</code> 的右边有没有可能是解。</li></ol><p>说明：（1）做题的经验告诉我，「思考什么时候不是解」比较好想。生活中其实也是这样，我往往说不大清楚我想要什么，但是我很确定我不想要什么；</p><p>之所以先考虑「什么时候不是解」，是因为做了很多题以后发现，这样考虑不容易出错。在 <code>if</code> 语句写对的情况下（建议把下一轮搜索的区间写下来，写在注释里，这样边界怎么设置就很清楚了，不容易乱）。<code>else</code> 的情况就不用思考了，肯定是 <code>if</code> 的反面。 然后我们注意一下 <code>mid</code> 是否需要上取整的问题，最后看看是否需要打个补丁判断一下 <code>left</code> 这个位置是不是我们要找的。这个算法就写完了。</p><p>（2）此时 <code>mid</code> 作为待查找数组的分界，就把它分为两个区间：一个部分可能存在目标元素，一个部分一定不存在目标元素。</p><p>根据 <code>mid</code> 被分到左边区间还是右边区间，代码写出来只有以下 2 种（重难点）：</p><p><strong>边界收缩行为 1</strong>： <code>mid</code> 被分到左边。即区间被分成 <code>[left, mid]</code> 与 <code>[mid + 1, right]</code>，这里用“闭区间”表示区间端点可以取到，下同；</p><p>代码写出来是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="if (check(mid)) {
  // 下一轮搜索区间是 [mid + 1, right]，因此把左边界设置到 mid + 1 位置
  left = mid + 1;
} else {
  // 上面对了以后，不加思考，剩下的区间一定是 [left, mid]，因此左边界向右收缩到 mid 位置
  right = mid;
}
" data-status="copy"></button><div class="token-line"><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span><span class="token plain">mid</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 下一轮搜索区间是 [mid + 1, right]，因此把左边界设置到 mid + 1 位置</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  left </span><span class="token operator">=</span><span class="token plain"> mid </span><span class="token operator">+</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 上面对了以后，不加思考，剩下的区间一定是 [left, mid]，因此左边界向右收缩到 mid 位置</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  right </span><span class="token operator">=</span><span class="token plain"> mid</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>说明：这里的 <code>check(mid)</code> 函数通常是一个表达式（例如上面的“参考代码 1”），在一些情况下有可能逻辑比较复杂，建议专门抽取成一个私有方法，以突显主干逻辑。</p><p><strong>边界收缩行为 2</strong>： mid 被分到右边。即区间被分成 [left, mid - 1] 与 [mid, right]；</p><p>同上，代码写出来是这样的（由于注释是对称的，这里省略，留给读者填充）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="if (check(mid)) {
  right = mid - 1;
} else {
  left = mid;
}
" data-status="copy"></button><div class="token-line"><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span><span class="token plain">mid</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  right </span><span class="token operator">=</span><span class="token plain"> mid </span><span class="token operator">-</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  left </span><span class="token operator">=</span><span class="token plain"> mid</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><ol start="3"><li>根据「边界收缩行为」修改取中间数的行为（重难点）</li></ol><p>先说一下中间数的取法。一般是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="const mid = (left + right) / 2;
" data-status="copy"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> mid </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">left </span><span class="token operator">+</span><span class="token plain"> right</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token operator">/</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>这种写法在绝大多数情况下没问题，但是在 <code>left</code> 和 <code>right</code> 特别大的场景中，<code>left + right</code> 会发生整形溢出，得到一个负数，<code>mid</code> 的值随之也是负数。改进的写法是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="const mid = left + (right - left) / 2;
" data-status="copy"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> mid </span><span class="token operator">=</span><span class="token plain"> left </span><span class="token operator">+</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">right </span><span class="token operator">-</span><span class="token plain"> left</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token operator">/</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>这两种写法事实上没有本质的区别，在 <code>left</code> 和 <code>right</code> 都表示数组索引的时候，几乎不会越界，因为绝大多数情况下不会开那么长的数组。</p><p>这里有一个细节，/ 是整除，它的行为是 <code>向下取整</code>，造成了 <code>const mid = (left + right) / 2</code> 这种写法 <code>mid</code> 永远取不到带搜索区间里最右边的位置（读者可以举一个只有 2 个元素的子数组，理解这句话）。</p><p>面对上面的 <code>边界收缩行为 2</code>（<code>mid</code> 被分到右边），在待搜索区间收缩到只剩下 2 个元素的时候，就有可能（请读者在练习的过程中体会这里我的描述为什么是 <strong>有可能</strong> 而不是 <strong>一定</strong>）造成死循环。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="var searchInsert = function(nums, target) {
  let left = 0,
    right = nums.length - 1;

  while (left &lt;= right) {
    const mid = Match.floor((left + right) / 2);

    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] &lt; target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return left;
};
" data-status="copy"></button><div class="token-line"><span class="token keyword">var</span><span class="token plain"> </span><span class="token function-variable function">searchInsert</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token parameter punctuation">,</span><span class="token parameter"> target</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> left </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">0</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    right </span><span class="token operator">=</span><span class="token plain"> nums</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token plain"> </span><span class="token operator">-</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">while</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">left </span><span class="token operator">&lt;=</span><span class="token plain"> right</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">const</span><span class="token plain"> mid </span><span class="token operator">=</span><span class="token plain"> </span><span class="token maybe-class-name">Match</span><span class="token punctuation">.</span><span class="token method function property-access">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token plain">left </span><span class="token operator">+</span><span class="token plain"> right</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token operator">/</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">nums</span><span class="token punctuation">[</span><span class="token plain">mid</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token operator">===</span><span class="token plain"> target</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token keyword">return</span><span class="token plain"> mid</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token keyword">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">nums</span><span class="token punctuation">[</span><span class="token plain">mid</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token operator">&lt;</span><span class="token plain"> target</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      left </span><span class="token operator">=</span><span class="token plain"> mid </span><span class="token operator">+</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"> </span><span class="token keyword">else</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      right </span><span class="token operator">=</span><span class="token plain"> mid </span><span class="token operator">-</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> left</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/leetcode/edit/master/docs/leetcode/35-search-insert-position.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last Update: ">9/10/2020, 4:48:41 PM</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/data-structure-and-algorithms-guidebook/umi.js"></script>
    <script src="/data-structure-and-algorithms-guidebook/docs__leetcode__35-search-insert-position.md.js"></script>
  </body>
</html>
