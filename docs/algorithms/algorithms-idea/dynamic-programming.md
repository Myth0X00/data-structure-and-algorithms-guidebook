---
nav:
  title: 算法
  order: 2
group:
  title: 算法思想
  order: 5
title: 动态规划
order: 4
---

# 动态规划

动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。

## 算法思想

基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。

## 算法特性

以下三个动态规划的性质可用于判断动态规划方法是否适用于给定的问题。

1. **最优子结构**：在自下而上的递推过程中，我们求得的每个子问题一定是全局最优解，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是全局最优解。
2. **无后效性**：无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。
3. **重叠子问题**：在求解原问题的时候，我们往往需要依赖其子问题，子问题依赖其子子问题，甚至可能同时依赖多个子问题，因此子问题之间是有重叠关系的。

## 设计思路

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。

```
初始状态 -> 决策 1 -> 决策 2 -> ... -> 决策 n -> 结束状态
```

1. 划分阶段
2. 确定状态和状态变量
3. 确定决策并写出状态转移方程
4. 寻找边界条件

一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。

实际应用中可以按以下几个简化的步骤进行设计：

1. 分析最优解的性质，并刻画其结构特征
2. 递归的定义最优解
3. 以自底向上或自顶向下的记忆方式（备忘录法）计算出最优解
4. 根据计算最优值时得到的消息，构造问题的最优解

### 状态转移表法

### 状态转移方程法

```js
dp[n] = dn[n - 1] + dp[n - 2];
```

具备三要素，确认边界条件，初始化状态，开始切菜：

- `dp[0] = 1`
- `dp[1] = 1`

```js
const climbStairs = function (n) {
  const dp = [];

  dp[0] = 1;
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
};
```

优化

```js
const climbStairs = function (n) {
  let a1 = 1;
  let a2 = 1;

  for (let i = 2; i <= n; i++) {
    [a1, a2] = [a2, a1 + a2];
  }

  return a2;
};
```

## 经典问题

### 斐波那契数列

### 最长公共子串

### 0-1 背包问题

对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？

```js
// weight 物品重量
// n 物品个数
// w 背包可承载重量
const knapsack = function (weight, n, w) {};
```

### 杨辉三角

## 相关问题

- 基础题目
  - 509 斐波那契数
  - 70 爬楼梯
  - 746 使用最小花费爬楼梯
  - 62 不同路径
  - 63 不同路径 II
  - 343 整数拆分
  - 96 不同的二叉搜索树
- 背包问题
  - 01 背包
    - 416 分割等和子集
    - 1049 最后一块石头的重量
    - 494 目标和
    - 474 一和零
  - 完全背包
    - 518 零钱兑换 II
    - 377 组合总和 IV
    - 70 爬楼梯
    - 322 零钱兑换
    - 279 完全平方数
    - 139 单词拆分
- 打家劫舍
  - 198 打家劫舍
  - 213 打家劫舍 II
  - 337 打家劫舍 III
- 股票问题
  - 121 买卖股票的最佳时机（只能买卖一次）
  - 122 买卖股票的最佳时机 II（可以买卖多次）
  - 123 买卖股票的最佳时机 III（最多买卖两次）
  - 188 买卖股票的最佳时机 IV（最多买卖 K 次）
  - 309 最佳买卖股票的最佳时机含冷冻期（买卖多次，卖出有一天冷冻期）
  - 714 买卖股票的最佳时机含手续费（买卖多次，每次有手续费）
- 子序列问题
  - 子序列（不连续）
    - 300 最长上升子序列
    - 1143 最长公共子序列
    - 1035 不相交的线
  - 子序列（连续）
    - 674 最长连续递增序列
    - 718 最长重复子数组
    - 53 最大子序和
  - 编辑距离
    - 392 判断子序列
    - 115 不同的子序列
    - 583 两个字符串的删除操作
    - 72 编辑距离
  - 回文
    - 647 回文子串
    - 516 最长回文子序列

## 算法思想归纳总结

|                  | 标准分治           | 动态规划           | 贪心算法           |
| :--------------- | :----------------- | :----------------- | :----------------- |
| 适用类型         | 通用问题           | 优化问题           | 优化问题           |
| 子问题结构       | 每个子问题不同     | 很多子问题重复     | 只有一个子问题     |
| 最有子结构       | 不需要             | 必须满足           | 必须满足           |
| 子问题数         | 全部子问题都要解决 | 全部子问题都要解决 | 只要解决一个子问题 |
| 子问题在最优解里 | 全部               | 部分               | 部分               |
| 选择与求解次序   | 先选择后解决子问题 | 先解决子问题后选择 | 先选择后解决子问题 |

## 参考资料
